---
title: 刷题日记25-03-05
date: 2025-03-05
categories: [题解,acm]
excerpt: 博主2025-03-05的刷题日记
---

# 刷题日记25-03-05

# acm 和 cf上分问题

- 保持思考，不要盲目刷题，脱离单调重复、没有提升的状态，不要把抄题解当成学习，区别很大
- 了解和评估当前状态
- 需要学习新算法，还有很多主题
- 接触更多平台，不一定局限于cf



# 170edu

## B

需要推公式，发现要求的就是2的幂次

实际上就是二项式展开



## C

简单，排序去重，开桶计数，双指针求连续区间最值



## D

题意：你扮演一个角色，初始“力量”（Strength）和“智力”（Intelligence）属性为 0。游戏中有n个记录，按顺序发生：

- 如果记录 ri=0，获得 1 个属性点，可选择加到力量或智力（总点数M）。
- 如果 ri>0，进行智力检查，要求智力 ≥ri才能通过。
- 如果 ri<0，进行力量检查，要求力量 ≥−ri 才能通过。
   目标是合理分配 M 个属性点，最大化通过的检查次数。

实际上是差分优化dp，定义 dp(i,x)表示前 i个记录，智力值为x时的最大通过次数（因为前i个数字的点数已知，所以可以知道力量点数）

分成三类进行状态转移

````cpp
else if(a[i] == 0) // 这是ai=0的时候，需要区间修改dp数组，也就是用差分数组优化的
{
    now++; // 表示当前所有可加的点数
    for (int j = 0; j <= now; j++)
    {
        if (j) dif[j] += dif[j - 1];
        dp[j] += dif[j];
    } // 相当于懒惰处理/写回，只有需要修改的时候再把差分数组作前缀和之后加回去
    for (int j = now; j >= 1; j--)
    {
        dp[j] = max(dp[j], dp[j - 1]);
    } // 因为滚动掉了第一维表示前i个数字的
    // 所以看起来是原地继承，实际上是在决策加到哪个数值上
    // 而且注意要反向遍历，恰好不影响
    for (int i = 0; i <= now; i++)
        dif[i] = 0;
    // 不可以clear
}
````



# 1007div2

## B

构造题。题意：给定一个正整数 n，要求构造一个长度为 n 的完美排列 p，其中“完美”定义为：对于每个 i（1≤i≤n），前 ii个元素之和 p1+p2+⋯+pi不是完全平方数。如果无法构造，则输出 −1。

如果 $n(n+1)/2 $是完全平方数，则无论如何排列，i=n时和都是完全平方数，无法满足完美条件。

**调整策略**：

- 计算前缀和 sum[i]=a[1]+⋯+a[i]
- 如果 sum[i]是完全平方数，交换 a[i]和 a[i+1]

- 交换后，sum[i]变为 sum[i−1]+a[i+1]，打破了完全平方性质



## C

树上序列，也是构造题

构造方法是把en结点当树根，求出所有点深度，从深到浅输出排列即可

当前所在的具体节点位置无需考虑，只需要管可能的倾向即可



## D

需要注意到，如果m为偶数，递归之后相邻两个数字的异或和=0，可以抵消，利用这点递归求解

预处理出异或前缀和，直接查询即可

需要熟悉异或性质，也算是思维题

```cpp
function<int(int)> dfs = [&](int x)
{
    if (x <= n) return get_xor(a, x, x); // 也就是本身
    if (x / 2 <= n) return get_xor(a, 1, x / 2);
    int ans = get_xor(a, 1, n);
    if ((x / 2) % 2 == 0) ans ^= dfs(x / 2); // 如果一半是奇数，已经抵消，但如果是偶数，就要计算
    if (n % 2 == 0) ans ^= dfs(n + 1); // 如果是奇数，已经抵消，只用算一次，不用递归
    return ans;
};
```


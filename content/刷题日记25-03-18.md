四天没有更新博客，我来回想一下这几天都在干什么。

- 周六给博客添加了一个搜索框功能，开启了一个新的分支。当时是使用单文件sqlite数据库，加中文分词插件的，但是中文分词插件nodejieba需要c的动态链接库支持，和vercel上的gilbc版本不兼容，于是几经周折切换成了jieba-wasm，又配置折腾了好久，可部署时提示serveless function的内存超出限额。最后搁置了，博客网站的版本也有些混乱了。晚上在和某人开心玩耍。

- 周日在图书馆呆了很久，学了一段时间计网，看了会英诗金库，看完了晚春和步履不停。
- 周一很多时间用来学习qt了，迅速配好了环境（花了不少时间），然后构建了几个小项目，最后用qt来完成了互联网编程的java项目（让ai边写边教的）
- 周二，也就是今天，实际上很多时间真的在上课，因为三节课都是新选的。数据库内核估计要花很多时间了。英语文学有点烂，但是为了督促自己学，最好还是上一下，而且退课麻烦。计算机视觉似乎有点枯燥。另外继续学习qt，改进[cpp qt项目]([Garhlz/chatter_demo](https://github.com/Garhlz/chatter_demo))。这真的是我的第一个cpp项目，之前只会写单文件的算法题，也算是学到了很多东西。最后，我打算刷一会题，就算是复习一下也好。
- 最后我在睡前怎么样也算是复习了两场，唉。写点水题骗骗自己



# CF173edu

2.13写的，印象不是很深了

## CF173edu_B

数学（1100，黄）

**题意：**

Artem 在黑板上连续写了 $n!$ 次数字 $d$。所以，他得到了数字 $dddddd…ddd$（正好是 $n!$ 个数字)。

现在，他很好奇黑板上写的数字能够被从 $1$ 到 $9$ 的哪些奇数整除。
第一行包含一个整数 $t$ $(1 \le t \le 100)$，表示测试用例的数量。接下来是 $t$ 个测试用例。

每个测试用例由一行组成，包含两个整数 $n$ 和 $d$，$(2 \le n \le 10 ^ 9, 1 \le d \le 9)$。

**思路：**

- 3：n>=3 || d % 3==0 （把数位都看作1，则可以考虑阶乘包括的因数，也就是n的范围）
- 5：d % 5==0
- 7：n>=6 || d % 7 == 0 （因为111111%7==0，所以只要n>=6，数位就一定是6的倍数，可以整除）
- 9：d == 9 || n >= 6 || (d % 3 == 0 && n >= 3)



## CF173edu_C

思维，贪心，前缀和（1600，绿）

**题意：**

给定一个长度为 $n$ 的数组 $a$，其中除了至多一个 $i \in [0,n)$ 满足 $|a_i| \neq 1$ 以外，其余全部项均满足 $|a_i|=1$。

求该数组中全部可能的子数组和，以升序输出。子数组是原数组中一段连续的数组。

**思路：**

把区间分成三种（令那个非正负1的数字为x，位置为pos）：

- pos之前的连续区间
- 跨过pos的区间
- pos之后的连续区间

因为除了x之外的所有数字都是正负1，我们可以发现一个重要性质：**连续的区间的区间和大小也是连续的**。利用这个性质，只需要找到非跨过x的区间的区间和最值，以及跨过x的区间和最值，则最值之间的部分就是可以取的数字

代码实现很简单，只需要前缀和，记录之前遍历过的最小值和最大值即可。



## CF173edu_D

思维，gcd（1800，绿）

**题意：**

给出三个整数 $l,r,G$，要求找到一个数对 $A,B$ 满足 $l\le A\le B\le r$ 且 $\gcd (A,B) = G$，并且满足 $\left\vert A-B \right\vert$ 最大。

如果有多组解，选择 $A$ 的值最小的一个。

**思路：**

- 因为A，B的最大公因数是G，则同时除以G之后二者没有更大的公因数了。所以如果除掉之后，问题可以转换成寻找最远的互质点对。
- 因此我们把 l,r 除掉之后，寻找最远互质点对即可
- 从大到小枚举互质点对的距离，从左到右枚举左节点即可。有定理可以证明其时间复杂度可以接受

```cpp
int l, r, g; 
cin >> l >> r >> g; 
l += g - 1; 
l /= g, r /= g;
int len = r - l;
while (len >= 0)//区间内最远互质点对
{
    for (int i = l; i <= r - len; i++) // 枚举左端点，直接对应一个右端点
    {
        if (gcd(i, i + len) == 1)
        {
            cout << i * g << ' ' << (i + len) * g << '\n';
            return;
        }
    }
    len--;
}
cout << -1 << ' ' << -1 << '\n';
```

非常奇妙的trick，我估计是想不出来的



# CF995div3

## CF995div3_D

二分（1200，黄）

**题意：**

给定一个整数序列 $ a $，长度为 $ n $，其中第 $ i $ 个元素为 $ a_i $。此外，还有两个整数 $ x $ 和 $ y $，且满足 $ x \le y $。

如果一对整数 $ (i, j) $ 满足以下条件，则称其为有趣的：

- $ 1 \le i < j \le n $；
- 从序列 $ a $ 中同时移除位置 $ i $ 和 $ j $ 的元素后，剩余元素的和在 $ x $ 和 $ y $ 之间。

找出给定序列 $ a $ 中有多少对这样的有趣整数组合。

**思路：**

- 剩余元素和$s1 \in [x,y]$等价于$x + y \in [sum - y,sum - x]$
- 排序（可以计数去重）
- 对于每一个左端点，二分出右端点的范围
- 根据当前左端点是否在右端点范围内来分类讨论，确保不重不漏

如下是一个计数去重的写法，有点复杂化了，但是当时写的时候思路非常顺畅

```cpp
int n, x, y;
cin >> n >> x >> y;
vector<int> a(n + 1);
int s = 0;
map<int, int> mp;
for (int i = 1; i <= n; i++)
{
    cin >> a[i];
    s += a[i];
    mp[a[i]]++;
}

int l = s - y, r = s - x;
sort(a.begin() + 1, a.end());
a.erase(unique(a.begin() + 1, a.end()), a.end());
int cnt = a.size();
vector<int> b(cnt);
for (int i = 1; i <= cnt - 1; i++)
{
    b[i] = b[i - 1] = mp[a[i]];
}
int ans = 0;
for (int i = 1; i <= cnt - 1; i++)
{
    int p = lower_bound(a.begin() + 1, a.end(), l - a[i]) - a.begin();
    int q = upper_bound(a.begin() + 1, a.end(), r - a[i]) - a.begin() - 1;
    int sum = b[q] - b[p - 1];
    int x = mp[a[i]];
    if (p <= i && i <= q)
    {
        sum -= x;
        ans += sum * x;
        ans += x * (x - 1);
    }
    else
    {
        ans += sum * x;
    }
}
ans /= 2;
cout << ans << '\n';
```



## CF995div3_E

二分，思维，贪心（1600，黄）

**题意：**

伯兰德最大的商店收到了一批圣诞树，并已有 $n$ 位顾客前来欲购这些树。在销售启动前，商店需要统一为每棵树定价。为了合理制定价格，商店掌握了关于每位顾客的一些信息。

对于第 $i$ 位顾客，有两个已知整数 $a_i$ 和 $b_i$，它们定义了顾客的购物行为：

- 如果价格不超过 $a_i$，顾客将购买一棵树并给出正面评价；
- 如果价格超过 $a_i$ 但不超过 $b_i$，顾客仍会购买，但会留下负面评价；
- 如果价格高于 $b_i$，则顾客将不会购买。

在负面评价不超过 $k$ 条的前提下，你的任务是帮助商店计算出最大的可能收益。

**思路：**

- 一个重要的观察是设置的最大价格一定是某一个顾客的界限价格（属于a或者b），根据贪心的思路，如果比某个界限小但是没有超过，一定尽可能抬高价格
- 另外，同一个位置的b一定大于a，所以在相对次序中，如果从小到大排序，当前位置b对应的次序只可能会更往后。只需要查看满足条件的ai和bi的数量，然后相减，就是差评的数量。（因为正面评价和负面评价的集合没有交集，$count(i)(b_i \le price)$ 表示所有正面评价+负面评价的集合，而$count(i)(a_i \le price)$表示所有正面评价的集合，数量相减之后就是负面评价的集合
- 因此，只需要二分购买价格（在所有ai,bi排序去重之后的集合中），然后通过二分计算当前的满足条件的a，b的数量相减，然后检查是否满足k的限制即可
- check（）函数就是二分这个限制



## CF995div3_F

贪心，模拟，思维（2000，绿）

**题意：**

考虑一副有 $n$ 张牌的情况。牌中的位置从上到下编号为 $1$ 到 $n$。小丑位于位置 $m$ 。

$q$ 操作按顺序应用于牌组。在第 $i$ 次操作期间，您需要在位置 $a_i$ 处取出卡片并将其移动到牌堆的开头或末尾。例如，如果牌组是 [_2,1,3,5,4_] ，并且 $a_i$   =2 ，那么在操作之后牌组将是 [_1,2,3,5,4_]（从第二个位置开始的牌移动到开头）或 [_2,3,5,4,1_]（卡片从第二个位置移到最后）。

您的任务是计算每次操作后小丑可以所处的不同位置的数量。

**思路：**

- 每次维护小丑牌可能所在位置构成的区间，然后模拟区间变化，合并区间即可
- 对于每个$a_i$，遍历所有上一轮的区间，然后逐一更新即可
  - 如果ai < l，则ai如果移到最后，区间内的点要左移一位，区间更新为$[l-1,r]$
  - 如果ai > r，同理，区间更新为$[l,r+1]$
  - 否则，小丑牌可以移动到第一位或者最后一位
- 以下是代码：

```cpp
for (int i = 1; i <= q; i++)
{
    int x;
    cin >> x;
    vector<pii> now;
    for (auto [l, r] : a)
    {
        if (x < l)
        {
            now.push_back({l - 1, r});
        }
        else if (x > r)
        {
            now.push_back({l, r + 1});
        }
        else
        {
            if (l != r)
            {
                now.push_back({l, r});
            }
            now.push_back({1, 1});
            now.push_back({n, n});
        }
    }
    a.clear();
    sort(all(now));
    for (auto [l, r] : now)
    { // 合并区间之后推入a数组中
        if (a.empty() || a.back()[1] < l)
        {
            a.push_back({l, r});
        }
        else
        {
            a.back()[1] = max(a.back()[1], r);
        }
    }

    int ans = 0;
    for (auto [l, r] : a)
    {
        ans += r - l + 1;
    }
    cout << ans << ' ';
}
```

其实并不难，关键是要想到使用区间表示，并且分类讨论更新区间即可

​		

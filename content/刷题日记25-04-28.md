---
title: 刷题日记25-04-28
date: 2025-04-28
categories: [题解,acm]
excerpt: 4.26和4.27写的题目复盘
problems:
  - id: "72"
    name: "CF176edu_C"
    tags: ["二分", "枚举", "前缀和", "1500", "黄"]
  - id: "73"
    name: "CF176edu_D"
    tags: ["状态压缩", "dp", "枚举", "2000", "绿"]
  - id: "74"
    name: "abc379_D"
    tags: ["优先队列", "黄"]
  - id: "75"
    name: "abc379_F"
    tags: ["单调队列", "二分", "绿"]
  - id: "76"
    name: "abc400_C"
    tags: ["数学", "枚举", "黄"]
  - id: "77"
    name: "abc400_E"
    tags: ["质数", "筛法", "dp", "黄"]
  - id: "78"
    name: "abc400_F"
    tags: ["dp", "区间dp", "蓝"]
  - id: "79"
    name: "abc403_E"
    tags: ["字符串", "字典树", "绿"]
  - id: "80"
    name: "abc403_F"
    tags: ["记忆化搜索", "构造", "绿"]
---

很久没有更新这个博客了. 多进行总结肯定是有好处的. 只需要把一些重要的题目记录下来就可以了, 也方便我自己复习. 

# CF176edu
写于4.26, vp, 需要复盘c,d
## CF176edu_C

二分, 枚举, 前缀和(1500, 黄)

**题意:**

Monocarp 决定按照以下规则粉刷围栏：
- 每块木板必须被涂上恰好一种颜色；
- 使用的不同颜色总数必须恰好为两种；
- 相同颜色的木板必须形成连续序列，即对于所有被涂成同一颜色的木板对，它们之间不存在被涂成其他颜色的木板。

Monocarp 有 $m$ 种不同的颜料，其中第 $i$ 种颜色的颜料最多可以涂 $a_i$ 块木板。Monocarp 不会购买额外颜料。

你的任务是计算满足 Monocarp 所有描述的愿望的围栏涂色方式数目。两种涂色方式被认为是不同的，当且仅当存在至少一块木板在这两种方式中被涂成不同颜色。

**思路:**

一眼二分, 但是有一个实现细节需要注意:

- 先对序列排序, 二分每个颜色可以取到的第一个对应颜色的位置

  ```cpp
  auto it = lower_bound(all(a), max(n - x, 0ll));
  ```

- 可以发现之后每个位置都可以与当前颜色组合, 对于每对组合, x可以取到的最小值是n-y, 最大值是x, 数量也就是 x - (n - y) + 1

- 使用前缀和优化

- 需要注意, 如果$y \ge n-1$, y多出的部分永远不可能生效. 为了简化操作, 可以直接把所有大于等于n-1的y赋值为n-1即可

```cpp
int ans = 0;
for (int i = 0; i < m; i++) {
    int x = a[i];
    auto it = lower_bound(all(a), max(n - x, 0ll));
    if (it == a.end()) continue;
    int pos = it - a.begin();  // pos - n都可以取到
    if (pos <= i) pos = i + 1;
    if (pos >= m) continue;

    int cnt = m - 1 - pos + 1;
    ans += cnt * (x - n + 1) + pre[m - 1] - pre[pos - 1];
}
cout << ans * 2 << '\n';
```



## CF176edu_D

状态压缩, dp, 枚举(2000, 绿)

**题意:**

给定两个非负整数 $x$ 和 $y$。

你可以执行以下操作任意次数（包括零次）：选择一个正整数 $k$，并将 $x$ 或 $y$ 除以 $2^k$（向下取整）。此操作的代价为 $2^k$。但存在额外约束：每个 $k$ 值最多只能选择一次。

你的任务是计算使 $x$ 和 $y$ 相等所需的最小可能代价。

**思路:**

- 可以先通过$n^3$的dp预处理出x和y分别移动 i 和 j 位时的最小代价(n表示位数, 顶多取到60) . 

```cpp
void init() {
    memset(dp, 0x3f, sizeof(dp));
    dp[0][0] = 0;
    for (int i = 0; i < N; i++) {           // 第一维枚举的是偏移量
        for (int j = N - 1; j >= 0; j--) {  // x的偏移
            for (int k = N - 1; k >= 0; k--) {
                dp[min(N - 1, j + i)][k] = min(dp[min(N - 1, j + i)][k], dp[j][k] + (1LL << i));
                dp[j][min(N - 1, k + i)] = min(dp[j][min(N - 1, k + i)], dp[j][k] + (1LL << i));
            }
        }
    }
}
```

- 然后对于每个查询, 直接枚举右移这么多位之后是否相等, 如果相等, 取最小代价即可

```cpp
int x, y;
cin >> x >> y;
int ans = LLONG_MAX;
for (int i = 0; i < N; i++) {
    for (int j = 0; j < N; j++) {
        if ((x >> i) == (y >> j)) {
            ans = min(ans, dp[i][j]);
        }
    }
}
cout << ans << '\n';
```

其实根本不是很难, 但是不容易想到直接dp预处理这个位移-代价的数组



# abc379

写于4.26, vp, 需要复盘d,f

## abc379_D

优先队列(黄)

**题意:**

高桥有 $10^{100}$ 个花盆。起初花盆都是空的。

你将有 $Q$ 次操作。有三种类型的操作，如下所示：

- `1`：准备一个空花盆，在里面放一颗植物，植物高度为 $0$。
- `2 T`：等待 $T$ 天。在此期间，所有植物的高度增加了 $T$。
- `3 H`：收割所有高度至少为 $H$ 的植物，并输出符合条件的植物数量，将符合条件的植物从花盆中取出。

假定执行 $1$ 和 $3$ 类型的操作花费时间为 $0$。且**一定会有操作 $3$**。

**思路:**

- 如果直接模拟, 涉及添加结点, 范围修改, 范围查询, 可以用一个动态范围的线段树表示. 但是那样太麻烦了.

- 关键在于, 操作2不一定直接修改高度, 只需要维护一个height变量表示目前已经增加过的高度即可
- 但是那样的话, 增加新的高度=0的植物如何处理? 很简单, 只需要添加一个高度为-height的植物即可
- 用一个大根堆维护, 每次遇到操作3的时候出队, 每个植物的高度就是pq.top() + height, 和 H 比较即可

```cpp
int q;
cin >> q;
priority_queue<int> pq;
int now = 0;
while (q--) {
    int op, x;
    cin >> op;
    if (op == 1) {
        pq.push(-now);
        // 这里是关键, 因为新加入的点不可以享受之前的提高, 所以直接设置为-now, 因此now不会更新, 简单而优雅
    } else if (op == 2) {
        cin >> x;
        now += x;
    } else {
        cin >> x;
        int ans = 0;
        while (!pq.empty()) {
            if (pq.top() + now >= x) {
                ans++;
                pq.pop();
            } else
                break;
        }
        cout << ans << '\n';
    }
}
```

一开始我就想到了线段树做法, 没有想到这个插入-height的做法. 另外, 因为队列的高度是单减的, 所以其实可以不需要优先队列, 直接用一个双指针维护当前有效的结点范围即可, 如果遇到操作3, 二分出第一个<h的位置即可, 然后移动慢指针即可. 这样的时间复杂度应该更优. 甚至不需要二分, 直接遍历, 复杂度已经是O(n), 因为一个点只能入队出队一次



## abc379_F

单调队列, 二分(绿)

**题意:**

有一排从西到东的 N 栋楼，每栋楼都有一个高度。对于两栋楼 i 和 j (i<j)，如果它们之间没有比楼 j 更高的楼，那么楼 j 就可以从楼 i 看到。

现在有 Q 个询问，每个询问会给你两个楼的编号 li 和 ri (li<ri). 对于每个询问，你需要找出在楼 ri 东边的所有楼（也就是楼 ri+1,ri+2,…,N 中），有多少栋楼同时能被楼 li 和楼 ri 看到。

**思路:**

使用可持续化线段树可以在线处理.  这里提供使用单调队列离线处理的方案. 

- 从右到左遍历, 维护一个序号递减, 序号对应的高度也递减的单点队列(单调栈)
- 因为可以看到的结点一定都是 id >= r, 高度随id单调递增
- 如果l, r之间有更高的点, 服从单调栈的入队规则, 会直接把之后的点挤出, 非常合理
- 插入: 找到第一个高度大于等于当前结点的位置p, p之后的点全都出栈, 把当前结点插入到p+1的位置

```cpp
// 入栈, 需要所有比它小的都要出栈, i表示当前结点编号, tot表示栈顶, a是高度数组, st是栈数组
while (tot && a[st[tot]] < a[i]) tot--;
st[++tot] = i;
```

- 然后把所有查询离线化: 每个 l 对应一个pair数组, 表示 l 对应的所有查询的{r, id}
- 对于每个r, 在单调栈中而分出第一个序号比它大的点的位置. 这个位置之前的所有点就是$(l,r)$可以看到的所有点, 直接加上数量即可

```cpp
 for (int i = n; i >= 1; i--) {
    for (auto [j, id] : query[i]) {
        int l = 1, r = tot;
        while (l < r) { // 栈内的序号和高度都是单调的
            int m = (l + r + 1) / 2;
            if (st[m] > j) l = m;
            else r = m - 1;
        }
        if (st[l] <= j) ans[id] = 0;
        else ans[id] = l;
    }
    while (tot && a[st[tot]] < a[i]) tot--;
    st[++tot] = i;
}
```



# abc400

## abc400_C

数学, 枚举(黄)

**题意:**

当且仅当满足以下条件时，正整数 $X$ 被称为好整数：

- 存在正整数对 $(a, b)$，使得 $X = 2^a \times b^2$。

例如，$400$ 可以表示为 $400 = 2^2 \times 10^2$，因此它是一个好整数。

给定正整数 $N$，请计算 $1$ 以上 $N$ 以下（含）的好整数的个数。

- $1 \le N \le 1^{18}$

**思路:**

- 显然可以枚举 a ,然后计算对应的完全平方数的数量
- 但是问题在于目标要计算“好整数”的数量而不是数对的数量, 因此会有重复的数字出现
- 因为$X = 2^a \times b^2$, 如果b的因子中含有2, 则会出现重复计算的情况, 因此我们只计算奇数b的数量
- X的所有因数2都由$2^a$构成, 由此可以实现不重不漏

```cpp
for (int a = 1;; a++) {
    int now = (1ll << a);
    int t = n / now;
    if (t == 0) break;
    int t1 = (int)sqrt(t);
    if (t1 & 1) ans++;
    ans += t1 / 2; // 在这里稍作改变即可
}
```



## abc400_E

质数, 筛法, dp(黄)

**题意:**

对于正整数 $N$，当且仅当满足以下两个条件时，$N$ 被称为 **400 number**：

- $N$ 恰好有 $2$ 种不同的素因数。
- 对于 $N$ 的每个素因数 $p$，$N$ 被 $p$ 整除的次数为偶数次。更严格地说，对于 $N$ 的每个素因数 $p$，使得 $p^k$ 是 $N$ 的约数的最大非负整数 $k$ 是偶数。

给定 $Q$ 个查询，请回答每个查询。每个查询给出一个整数 $A$，请找出不超过 $A$ 的最大 400 number 的值。在本问题的约束条件下，保证 $A$ 以下必定存在至少一个 400 number。

**思路:**

要寻找不超过A的最大的质因数数量=2的数字, 而且质因数的幂次都是偶数. 这个数字开方之后, 问题转化成了寻找最大的不超过$sqrt(A)$且质因数的数量恰好为2的数字

- 可以通过欧拉筛找出质数(也就是线性筛的同时记录每个数字的最小质因数)

```cpp
void Euler() {  // 就是在线性筛的同时记录最小质因子
    is_prime[1] = 1;
    for (int i = 2; i < N; i++) {
        if (!is_prime[i]) {
            prime.push_back(i);
            p[i] = i;
        }
        for (int j = 0; j < prime.size() && i * prime[j] < N; j++) {
            is_prime[i * prime[j]] = 1;
            // i是倍数, prime[j]是质数, 标记i * prime[j]是合数,最小质因数是prime[j]
            p[i * prime[j]] = prime[j];
            if (i % prime[j] == 0) break;
            // 之后再标记, 就有更小的质因数了, 也就是i中包含的prime[j]这个数字
        }
    }
}
```



- 可以通过递推计算当前数字的质因数数量, 然后根据当前数字的质因数数量是否=2来决定当前数字满足条件或者继承上一个数字的满足条件最大值:

```cpp
void init() {
    factor_num[1] = 0;
    for (int i = 2; i < N; i++) {
        int k = i / p[i];  // p[i]是当前最小质因子已知, 另一部分从之前的序列中转移即可
        if (k % p[i] == 0)
            factor_num[i] = factor_num[k];  // 说明当前质因子p[i]是重复的
        else
            factor_num[i] = factor_num[k] + 1;  // 当前质因子p[i]是新的

        if (factor_num[i] == 2) {
            dp[i] = i * i;  // 当前数字本身满足条件, 平方之后就是要求的数字
        } else {
            dp[i] = dp[i - 1];  // 继承
        }
    }
}
```

- 最后直接对于每个查询, 开方取整之后在dp数组中查找即可:

```cpp
while (q--) {
    int x;
    cin >> x;
    x = (int)sqrt(x);
    cout << dp[x] << "\n";
}
```

可以发现其实思路并不难, 也没有涉及过于复杂的数论算法, 但是要求熟练利用欧拉筛和递推继承来求出因数数量. 可以说判为黄题很合理



## abc400_F

dp, 区间dp(蓝)

**题意:**

存在一个被沿着半径切割成 $N$ 等分的圆形蛋糕。

各分块按顺时针方向编号为 $1, 2, \ldots, N$。此外，对于满足 $1 \leq i \leq N$ 的整数 $i$，分块 $i$ 也可以被称为分块 $N + i$。

初始时，所有分块的颜色均为颜色 $0$。

你可以执行以下操作任意次数：

- 选择满足 $1 \leq a, b, c \leq N$ 的整数 $a, b, c$。对于每个满足 $0 \leq i < b$ 的整数 $i$，将分块 $a + i$ 的颜色修改为颜色 $c$。此操作需花费 $b + X_c$ 的成本。

请找出使得所有满足 $1 \leq i \leq N$ 的整数 $i$ 对应的分块 $i$ 颜色变为 $C_i$ 时，所需总成本的最小值。

**思路:**

- 显然是区间dp, 把环拆成两倍序列即可
- 定义 `dp[i][j]`为将区间(i,j)完成涂色的最小成本
- 先预处理长度为1的区间(点): `for (int i = 1; i <= n * 2; i++) dp[i][i] = x[c[i]] + 1;`
- 然后常规区间dp, 先枚举区间长度, 然后枚举起始点, 然后是分段点
- 注意, 这里的分段点(k)逻辑为:  `f[l][x] 覆盖 [l,x] ，扩展到 r ，成本增加了 r−x`. 也就是说, 染色的颜色成本已经计算在dp(l,x)中了, 只需要新增扩展染色长度的成本即可

```cpp
for (int len = 2; len <= 2 * n; len++) {
    for (int l = 1; l + len - 1 <= 2 * n; l++) {
        int r = l + len - 1;
        dp[l][r] = dp[l][r - 1] + dp[r][r];
        for (int k = l; k < r; k++) {
            if (c[k] == c[r]) {
                dp[l][r] = min(dp[l][r], dp[l][k] + r - k + dp[k + 1][r - 1]);
                // x对应的代价已经计算过了, 只需计算长度的代价
            }
        }
    }
}
```

其实也算很常规的区间dp了, 但是由于太久没有处理过这一类题目, 有点摸不着头脑...



# abc403

做于4.27赛时, 半个小时不到过了前四题, 然后一直在调F, 但是没有成功

## abc403_E

字符串, 字典树(绿)

**题意:**

现有两个字符串多重集合 $X$ 和 $Y$，初始时均为空集合。

需要依次处理 $Q$ 个查询。第 $i$ 个查询给出整数 $T_i$ 和字符串 $S_i$：
- 若 $T_i=1$，则将 $S_i$ 加入 $X$
- 若 $T_i=2$，则将 $S_i$ 加入 $Y$

在每个查询处理完成后，请输出以下值：
- $Y$ 中满足"不以 $X$ 中任何字符串作为前缀"的字符串数量。

**思路:**

看到前缀, 在线, 想到字典树. 赛时想到了字典树, 但是没有深入思考

- 维护一棵字典树, 表示不以 $X$ 中任何字符串作为前缀 $Y$ 中的字符串. 每个结点还需要额外维护子树的有效叶子节点的数量, 以及它的父节点id, 还需要对插入过在这里结束的X字符串末尾结点打上标记. 因为Y中的字符串可以是重复的, 所以要额外维护数量

```cpp
int now = 0;
for (char c : s) {               // 移动指针
    if (t[now].zt == 1) return;  // 已经有x经过了
    int id = c - 'a';
    if (!t[now].ch[id]) {
        t.emplace_back();  // 动态扩容
        t[now].ch[id] = t.size() - 1;
        t.back().fa = now;
    }
    now = t[now].ch[id];
}
if (t[now].zt == 1) return;
```

- 如果插入X字符串, 没有遇到先前插入的X字符串末尾标记, 就找到以当前X字符串末尾为根对应的子树, 这些Y字符串都需要删除掉. 如何删除呢? 直接暴力向上跳转到根节点, 全都减去以当前X字符串末尾为根对应的子树的叶子节点数量即可

```cpp
if (op == 1) {
    t[now].zt = 1;  // x标记终结点
    if (t[now].ans > 0) {
        int del = t[now].ans;
        t[now].ans = 0;
        while (now) {  // 删除这个子树的所有结点数量
            now = t[now].fa;
            t[now].ans -= del;
        }
    }
}
```

- 如果插入Y字符串,没有遇到先前插入的X字符串末尾标记, 就从当前Y字符串末尾对应的结点一直跳转到根节点, 每个节点的叶子数量+1

```cpp
else {
    t[now].ans++;
    while (now) {
        now = t[now].fa;
        t[now].ans++;
    }
}
```

只能说是太久没有做相关的题目了. 这道题似乎也可以用字符串哈希处理(离线?)



## abc403_F

记忆化搜索, 构造(绿)

**题意:**

给定一个正整数 $N$。

请找出由字符 `1`、`+`、`*`、`(`、`)` 组成的数学表达式中，满足以下所有条件的最短表达式 $S$：
1. $S$ 符合以下 [BNF 语法](https://ja.wikipedia.org/wiki/%E3%83%90%E3%83%83%E3%82%AB%E3%82%B9%E3%83%BB%E3%83%8A%E3%82%A6%E3%82%A2%E8%A8%98%E6%B3%95) 中 `<expr>` 符号的定义
2. $S$ 表示的数学表达式计算结果等于 $N$

BNF 语法定义如下：

```
<expr>   ::= <term> | <expr> "+" <term>
<term>   ::= <factor> | <term> "*" <factor>
<factor> ::= <number> | "(" <expr> ")"
<number> ::= "1" | "1" <number> 
```

符合 `<expr>` 定义的表达式示例：
- `1111+111`：表示 $1111+111$
- `(1+1)*(1+1)`：表示 $(1+1)\times (1+1)$
- `(11+(1+1)*(1+1))+1`：表示 $(11+(1+1)\times (1+1))+1$

**思路:**

赛时一直卡到最后, 甚至到晚上都没有ac. 主要在于当时脑子莫名陷入了死胡同, 忽略了两点:

1. 只需要分类讨论两数相加或者两数相乘即可, 于是记忆化搜索显然比直接递推更好
2. 括号的条件忽视了. 其实很简单, 如果当前使用了乘号, 而其中一个表达式是加法表达式, 就需要加上额外的括号, 其他时候并不需要. 因此在题解中, 直接维护了每个值的最短表达式string, 以及是否为加法表达式的bool值

以下是ai改的代码, 码风和命名非常完美, 值得学习:

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 2002;
vector<pair<string, bool>> sum(N);

pair<string, bool> solve(int x) {
    if (x == 1) return {"1", false};
    if (x == 11) return {"11", false};
    if (x == 111) return {"111", false};
    if (x == 1111) return {"1111", false};
    if (!sum[x].first.empty()) return sum[x];

    string best_s;
    bool is_sum = false;
    int min_len = INT_MAX;

    // 乘法分解
    for (int i = 2; i * i <= x; ++i) {
        if (x % i == 0) {
            auto [s1, sum1] = solve(i);
            auto [s2, sum2] = solve(x / i);
            if (sum1) s1 = "(" + s1 + ")";
            if (sum2) s2 = "(" + s2 + ")";
            int len = s1.size() + 1 + s2.size();
            if (len < min_len) {
                min_len = len;
                best_s = s1 + "*" + s2;
                is_sum = false;
            }
        }
    }

    // 加法分解
    for (int i = 1; i <= x / 2; ++i) {
        auto [s1, sum1] = solve(i);
        auto [s2, sum2] = solve(x - i);
        int len = s1.size() + 1 + s2.size();
        if (len < min_len) {
            min_len = len;
            best_s = s1 + "+" + s2;
            is_sum = true;
        }
    }
    
    return sum[x] = {best_s, is_sum};
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n;
    cin >> n;
    cout << solve(n).first << '\n';
    return 0;
}
```

可以看到, 思路基本上算是一目了然. 赛时我的方向都错了, 一直在想分解成a+b*c的形式, 但是其实没有触及根本. 只需要分成加法和乘法两种情况, 然后递归自然就会求出最优的组合.